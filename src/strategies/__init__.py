"""
Trading Strategies - Implementations of various DeFi trading strategies
"""

from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from decimal import Decimal
import asyncio
from enum import Enum
import numpy as np
import pandas as pd
from dataclasses import dataclass
from abc import ABC, abstractmethod

from loguru import logger
from pydantic import BaseModel, Field


class StrategyStatus(Enum):
    """Strategy execution status"""
    IDLE = "idle"
    SCANNING = "scanning"
    EXECUTING = "executing"
    MONITORING = "monitoring"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class TradeSignal:
    """Trading signal generated by strategy"""
    signal_type: str  # buy, sell, hold
    confidence: float  # 0-1
    token_pair: str
    chain: str
    suggested_amount: float
    reasoning: str
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    urgency: str = "normal"  # low, normal, high, urgent
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class BaseStrategy(ABC):
    """Base class for all trading strategies"""
    
    def __init__(self, name: str, parameters: Dict[str, Any]):
        self.name = name
        self.parameters = parameters
        self.status = StrategyStatus.IDLE
        self.active_positions = {}
        self.trade_history = []
        self.performance_metrics = {
            "total_trades": 0,
            "successful_trades": 0,
            "total_pnl": 0.0,
            "win_rate": 0.0,
            "max_drawdown": 0.0,
            "sharpe_ratio": 0.0,
            "avg_trade_duration": 0.0
        }
        self.last_update = datetime.now()
        
    @abstractmethod
    async def initialize(self) -> bool:
        """Initialize strategy with required data and connections"""
        pass
    
    @abstractmethod
    async def generate_signals(self) -> List[TradeSignal]:
        """Generate trading signals based on strategy logic"""
        pass
    
    @abstractmethod
    async def execute_signal(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute a trading signal"""
        pass
    
    async def update_positions(self):
        """Update existing positions"""
        for position_id, position in self.active_positions.items():
            # Mock price update - in production, fetch real prices
            price_change = np.random.uniform(-0.02, 0.02)
            position["current_price"] *= (1 + price_change)
            position["unrealized_pnl"] = (
                position["current_price"] - position["entry_price"]
            ) * position["size"]
            position["pnl_percentage"] = (
                (position["current_price"] - position["entry_price"]) / 
                position["entry_price"]
            ) * 100
            position["last_updated"] = datetime.now()
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get strategy performance summary"""
        return {
            "strategy_name": self.name,
            "status": self.status.value,
            "last_update": self.last_update.isoformat(),
            "performance_metrics": self.performance_metrics,
            "active_positions": len(self.active_positions),
            "total_capital_deployed": sum(
                pos.get("size", 0) * pos.get("entry_price", 0) 
                for pos in self.active_positions.values()
            )
        }


class ArbitrageStrategy(BaseStrategy):
    """Cross-DEX and cross-chain arbitrage strategy"""
    
    def __init__(self, parameters: Dict[str, Any]):
        super().__init__("arbitrage", parameters)
        self.min_profit_threshold = parameters.get("min_profit_threshold", 0.005)  # 0.5%
        self.max_gas_cost = parameters.get("max_gas_cost", 100)
        self.supported_tokens = parameters.get("tokens", ["ETH", "USDC", "WBTC"])
        self.supported_chains = parameters.get("chains", ["ethereum", "polygon", "bsc"])
        self.dex_preferences = parameters.get("dex_preferences", {})
        
    async def initialize(self) -> bool:
        """Initialize arbitrage strategy"""
        logger.info(f"Initializing arbitrage strategy for {len(self.supported_tokens)} tokens")
        self.status = StrategyStatus.IDLE
        return True
    
    async def generate_signals(self) -> List[TradeSignal]:
        """Scan for arbitrage opportunities"""
        self.status = StrategyStatus.SCANNING
        signals = []
        
        try:
            for token in self.supported_tokens:
                # Mock arbitrage opportunity detection
                await asyncio.sleep(0.1)  # Simulate API calls
                
                opportunity = await self._detect_arbitrage_opportunity(token)
                if opportunity:
                    signal = TradeSignal(
                        signal_type="arbitrage",
                        confidence=opportunity["confidence"],
                        token_pair=f"{token}/USDC",
                        chain=opportunity["buy_chain"],
                        suggested_amount=opportunity["optimal_amount"],
                        reasoning=f"Arbitrage opportunity: Buy on {opportunity['buy_dex']} "
                                f"at ${opportunity['buy_price']:.4f}, "
                                f"sell on {opportunity['sell_dex']} "
                                f"at ${opportunity['sell_price']:.4f}. "
                                f"Expected profit: {opportunity['profit_percentage']:.2f}%",
                        urgency="high" if opportunity["profit_percentage"] > 1.0 else "normal"
                    )
                    signals.append(signal)
            
            self.status = StrategyStatus.IDLE
            return signals
            
        except Exception as e:
            logger.error(f"Error generating arbitrage signals: {e}")
            self.status = StrategyStatus.ERROR
            return []
    
    async def _detect_arbitrage_opportunity(self, token: str) -> Optional[Dict]:
        """Detect arbitrage opportunity for a token"""
        # Mock price data from different DEXs
        mock_prices = {
            "uniswap": np.random.uniform(2400, 2500) if token == "ETH" else np.random.uniform(0.998, 1.002),
            "sushiswap": np.random.uniform(2400, 2500) if token == "ETH" else np.random.uniform(0.998, 1.002),
            "curve": np.random.uniform(2400, 2500) if token == "ETH" else np.random.uniform(0.998, 1.002),
            "balancer": np.random.uniform(2400, 2500) if token == "ETH" else np.random.uniform(0.998, 1.002)
        }
        
        min_price_dex = min(mock_prices.keys(), key=lambda k: mock_prices[k])
        max_price_dex = max(mock_prices.keys(), key=lambda k: mock_prices[k])
        
        min_price = mock_prices[min_price_dex]
        max_price = mock_prices[max_price_dex]
        
        profit_percentage = ((max_price - min_price) / min_price) * 100
        gas_cost = np.random.uniform(20, 80)
        
        # Check if opportunity meets thresholds
        if profit_percentage > self.min_profit_threshold * 100 and gas_cost < self.max_gas_cost:
            return {
                "buy_dex": min_price_dex,
                "sell_dex": max_price_dex,
                "buy_price": min_price,
                "sell_price": max_price,
                "profit_percentage": profit_percentage,
                "gas_cost": gas_cost,
                "buy_chain": np.random.choice(self.supported_chains),
                "sell_chain": np.random.choice(self.supported_chains),
                "optimal_amount": min(1000 / min_price, 10),  # Max 10 tokens or $1000
                "confidence": min(profit_percentage / 2, 0.95)
            }
        
        return None
    
    async def execute_signal(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute arbitrage signal"""
        self.status = StrategyStatus.EXECUTING
        
        try:
            # Mock arbitrage execution
            position_id = f"arb_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Simulate trade execution delay
            await asyncio.sleep(1)
            
            execution_result = {
                "position_id": position_id,
                "strategy": self.name,
                "signal": signal,
                "execution_price": np.random.uniform(2450, 2550) if "ETH" in signal.token_pair else 1.0,
                "executed_amount": signal.suggested_amount,
                "gas_cost": np.random.uniform(20, 60),
                "status": "completed",
                "timestamp": datetime.now(),
                "expected_profit": signal.suggested_amount * 0.005  # 0.5% profit
            }
            
            # Add to active positions
            self.active_positions[position_id] = {
                "position_id": position_id,
                "token_pair": signal.token_pair,
                "entry_price": execution_result["execution_price"],
                "current_price": execution_result["execution_price"],
                "size": execution_result["executed_amount"],
                "strategy": self.name,
                "unrealized_pnl": 0,
                "created_at": execution_result["timestamp"]
            }
            
            self.trade_history.append(execution_result)
            self.performance_metrics["total_trades"] += 1
            
            self.status = StrategyStatus.MONITORING
            return execution_result
            
        except Exception as e:
            logger.error(f"Error executing arbitrage signal: {e}")
            self.status = StrategyStatus.ERROR
            return {"error": str(e)}


class YieldFarmingStrategy(BaseStrategy):
    """Automated yield farming and liquidity provision strategy"""
    
    def __init__(self, parameters: Dict[str, Any]):
        super().__init__("yield_farming", parameters)
        self.target_apy = parameters.get("target_apy", 15.0)
        self.auto_compound = parameters.get("auto_compound", True)
        self.max_il_risk = parameters.get("max_il_risk", 0.1)  # 10% impermanent loss
        self.preferred_protocols = parameters.get("protocols", ["uniswap", "sushiswap", "curve"])
        
    async def initialize(self) -> bool:
        """Initialize yield farming strategy"""
        logger.info("Initializing yield farming strategy")
        self.status = StrategyStatus.IDLE
        return True
    
    async def generate_signals(self) -> List[TradeSignal]:
        """Generate yield farming opportunities"""
        self.status = StrategyStatus.SCANNING
        signals = []
        
        try:
            for protocol in self.preferred_protocols:
                opportunities = await self._scan_yield_opportunities(protocol)
                
                for opp in opportunities:
                    if opp["apy"] >= self.target_apy:
                        signal = TradeSignal(
                            signal_type="yield_farm",
                            confidence=min(opp["apy"] / 30, 0.95),  # Higher APY = higher confidence
                            token_pair=opp["pair"],
                            chain=opp["chain"],
                            suggested_amount=opp["suggested_amount"],
                            reasoning=f"High yield opportunity on {protocol}: "
                                    f"{opp['apy']:.1f}% APY with {opp['tvl']} TVL. "
                                    f"Estimated IL risk: {opp['il_risk']:.1f}%",
                            urgency="normal"
                        )
                        signals.append(signal)
            
            self.status = StrategyStatus.IDLE
            return signals
            
        except Exception as e:
            logger.error(f"Error generating yield signals: {e}")
            self.status = StrategyStatus.ERROR
            return []
    
    async def _scan_yield_opportunities(self, protocol: str) -> List[Dict]:
        """Scan yield opportunities on a protocol"""
        # Mock yield farming pools
        pools = [
            {"pair": "ETH/USDC", "apy": np.random.uniform(8, 25), "tvl": "50M", "il_risk": 0.08},
            {"pair": "WBTC/ETH", "apy": np.random.uniform(12, 30), "tvl": "25M", "il_risk": 0.12},
            {"pair": "USDC/USDT", "apy": np.random.uniform(5, 15), "tvl": "100M", "il_risk": 0.02},
            {"pair": "ETH/MATIC", "apy": np.random.uniform(15, 40), "tvl": "10M", "il_risk": 0.15}
        ]
        
        opportunities = []
        for pool in pools:
            if pool["il_risk"] <= self.max_il_risk:
                opportunities.append({
                    "protocol": protocol,
                    "pair": pool["pair"],
                    "apy": pool["apy"],
                    "tvl": pool["tvl"],
                    "il_risk": pool["il_risk"],
                    "chain": np.random.choice(["ethereum", "polygon"]),
                    "suggested_amount": np.random.uniform(500, 2000)
                })
        
        return opportunities
    
    async def execute_signal(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute yield farming signal"""
        self.status = StrategyStatus.EXECUTING
        
        try:
            position_id = f"yield_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Simulate liquidity provision
            await asyncio.sleep(1.5)
            
            execution_result = {
                "position_id": position_id,
                "strategy": self.name,
                "signal": signal,
                "lp_tokens_received": signal.suggested_amount * 0.99,  # 1% slippage
                "pool_share": np.random.uniform(0.001, 0.01),  # 0.1-1% of pool
                "status": "active",
                "timestamp": datetime.now(),
                "expected_daily_yield": signal.suggested_amount * (self.target_apy / 100) / 365
            }
            
            # Add to active positions
            self.active_positions[position_id] = {
                "position_id": position_id,
                "token_pair": signal.token_pair,
                "entry_price": 1.0,  # LP token price
                "current_price": 1.0,
                "size": execution_result["lp_tokens_received"],
                "strategy": self.name,
                "unrealized_pnl": 0,
                "created_at": execution_result["timestamp"],
                "pool_info": {
                    "apy": self.target_apy,
                    "daily_yield": execution_result["expected_daily_yield"]
                }
            }
            
            self.trade_history.append(execution_result)
            self.performance_metrics["total_trades"] += 1
            
            self.status = StrategyStatus.MONITORING
            return execution_result
            
        except Exception as e:
            logger.error(f"Error executing yield farming signal: {e}")
            self.status = StrategyStatus.ERROR
            return {"error": str(e)}


class TrendFollowingStrategy(BaseStrategy):
    """Trend following strategy using technical indicators"""
    
    def __init__(self, parameters: Dict[str, Any]):
        super().__init__("trend_following", parameters)
        self.timeframes = parameters.get("timeframes", ["1h", "4h", "1d"])
        self.indicators = parameters.get("indicators", ["sma", "ema", "rsi", "macd"])
        self.trend_threshold = parameters.get("trend_threshold", 0.7)
        self.position_size = parameters.get("position_size", 0.1)  # 10% of portfolio
        
    async def initialize(self) -> bool:
        """Initialize trend following strategy"""
        logger.info("Initializing trend following strategy")
        self.status = StrategyStatus.IDLE
        return True
    
    async def generate_signals(self) -> List[TradeSignal]:
        """Generate trend following signals"""
        self.status = StrategyStatus.SCANNING
        signals = []
        
        try:
            tokens = ["ETH", "BTC", "MATIC", "AVAX"]
            
            for token in tokens:
                analysis = await self._analyze_trend(token)
                
                if analysis["trend_strength"] >= self.trend_threshold:
                    signal = TradeSignal(
                        signal_type="trend_follow",
                        confidence=analysis["trend_strength"],
                        token_pair=f"{token}/USDC",
                        chain="ethereum",
                        suggested_amount=analysis["suggested_position_size"],
                        reasoning=f"Strong {analysis['trend_direction']} trend detected for {token}. "
                                f"Trend strength: {analysis['trend_strength']:.2f}. "
                                f"Supporting indicators: {', '.join(analysis['supporting_indicators'])}",
                        stop_loss=analysis.get("stop_loss"),
                        take_profit=analysis.get("take_profit"),
                        urgency="normal"
                    )
                    signals.append(signal)
            
            self.status = StrategyStatus.IDLE
            return signals
            
        except Exception as e:
            logger.error(f"Error generating trend signals: {e}")
            self.status = StrategyStatus.ERROR
            return []
    
    async def _analyze_trend(self, token: str) -> Dict:
        """Analyze trend for a token using technical indicators"""
        # Mock technical analysis
        price_data = np.random.normal(2500 if token == "ETH" else 50000 if token == "BTC" else 1, 50, 100)
        
        # Simple moving averages
        sma_20 = np.mean(price_data[-20:])
        sma_50 = np.mean(price_data[-50:])
        current_price = price_data[-1]
        
        # Mock RSI
        rsi = np.random.uniform(30, 70)
        
        # Mock MACD
        macd = np.random.uniform(-10, 10)
        
        # Determine trend
        trend_direction = "bullish" if sma_20 > sma_50 and current_price > sma_20 else "bearish"
        
        # Calculate trend strength
        price_momentum = (current_price - sma_20) / sma_20
        sma_momentum = (sma_20 - sma_50) / sma_50
        
        trend_strength = min(abs(price_momentum) + abs(sma_momentum), 1.0)
        
        supporting_indicators = []
        if (trend_direction == "bullish" and rsi < 70) or (trend_direction == "bearish" and rsi > 30):
            supporting_indicators.append("RSI")
        if (trend_direction == "bullish" and macd > 0) or (trend_direction == "bearish" and macd < 0):
            supporting_indicators.append("MACD")
        
        return {
            "trend_direction": trend_direction,
            "trend_strength": trend_strength,
            "current_price": current_price,
            "sma_20": sma_20,
            "sma_50": sma_50,
            "rsi": rsi,
            "macd": macd,
            "supporting_indicators": supporting_indicators,
            "suggested_position_size": 1000 * self.position_size,
            "stop_loss": current_price * (0.95 if trend_direction == "bullish" else 1.05),
            "take_profit": current_price * (1.10 if trend_direction == "bullish" else 0.90)
        }
    
    async def execute_signal(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute trend following signal"""
        self.status = StrategyStatus.EXECUTING
        
        try:
            position_id = f"trend_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Simulate trade execution
            await asyncio.sleep(0.8)
            
            execution_result = {
                "position_id": position_id,
                "strategy": self.name,
                "signal": signal,
                "execution_price": np.random.uniform(2450, 2550) if "ETH" in signal.token_pair else np.random.uniform(49000, 51000),
                "executed_amount": signal.suggested_amount,
                "stop_loss_set": signal.stop_loss,
                "take_profit_set": signal.take_profit,
                "status": "active",
                "timestamp": datetime.now()
            }
            
            # Add to active positions
            self.active_positions[position_id] = {
                "position_id": position_id,
                "token_pair": signal.token_pair,
                "entry_price": execution_result["execution_price"],
                "current_price": execution_result["execution_price"],
                "size": execution_result["executed_amount"],
                "strategy": self.name,
                "unrealized_pnl": 0,
                "stop_loss": signal.stop_loss,
                "take_profit": signal.take_profit,
                "created_at": execution_result["timestamp"]
            }
            
            self.trade_history.append(execution_result)
            self.performance_metrics["total_trades"] += 1
            
            self.status = StrategyStatus.MONITORING
            return execution_result
            
        except Exception as e:
            logger.error(f"Error executing trend signal: {e}")
            self.status = StrategyStatus.ERROR
            return {"error": str(e)}


class DCAStrategy(BaseStrategy):
    """Dollar Cost Averaging strategy"""
    
    def __init__(self, parameters: Dict[str, Any]):
        super().__init__("dca", parameters)
        self.target_token = parameters.get("token", "ETH")
        self.amount_per_buy = parameters.get("amount_per_buy", 100)
        self.frequency_hours = parameters.get("frequency_hours", 24)  # Daily
        self.total_duration_days = parameters.get("duration_days", 30)
        self.last_purchase = None
        
    async def initialize(self) -> bool:
        """Initialize DCA strategy"""
        logger.info(f"Initializing DCA strategy for {self.target_token}")
        self.status = StrategyStatus.IDLE
        return True
    
    async def generate_signals(self) -> List[TradeSignal]:
        """Generate DCA signals based on timing"""
        self.status = StrategyStatus.SCANNING
        signals = []
        
        try:
            current_time = datetime.now()
            
            # Check if it's time for next purchase
            if (self.last_purchase is None or 
                (current_time - self.last_purchase).total_seconds() >= self.frequency_hours * 3600):
                
                signal = TradeSignal(
                    signal_type="dca_buy",
                    confidence=0.8,  # DCA is consistent, moderate confidence
                    token_pair=f"{self.target_token}/USDC",
                    chain="ethereum",
                    suggested_amount=self.amount_per_buy,
                    reasoning=f"Scheduled DCA purchase of ${self.amount_per_buy} worth of {self.target_token}. "
                            f"Part of {self.total_duration_days}-day DCA plan.",
                    urgency="low"  # DCA is not time-sensitive
                )
                signals.append(signal)
            
            self.status = StrategyStatus.IDLE
            return signals
            
        except Exception as e:
            logger.error(f"Error generating DCA signals: {e}")
            self.status = StrategyStatus.ERROR
            return []
    
    async def execute_signal(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute DCA purchase"""
        self.status = StrategyStatus.EXECUTING
        
        try:
            position_id = f"dca_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Simulate market buy
            await asyncio.sleep(0.5)
            
            current_price = np.random.uniform(2400, 2600) if self.target_token == "ETH" else np.random.uniform(49000, 51000)
            tokens_purchased = signal.suggested_amount / current_price
            
            execution_result = {
                "position_id": position_id,
                "strategy": self.name,
                "signal": signal,
                "execution_price": current_price,
                "tokens_purchased": tokens_purchased,
                "usd_amount": signal.suggested_amount,
                "status": "completed",
                "timestamp": datetime.now()
            }
            
            # Update last purchase time
            self.last_purchase = datetime.now()
            
            # DCA positions are typically held long-term, so we track cumulative position
            cumulative_position_id = f"dca_{self.target_token}_cumulative"
            
            if cumulative_position_id in self.active_positions:
                # Add to existing position
                existing = self.active_positions[cumulative_position_id]
                total_value = existing["size"] * existing["entry_price"] + signal.suggested_amount
                total_tokens = existing["size"] + tokens_purchased
                
                existing["entry_price"] = total_value / total_tokens  # New average price
                existing["size"] = total_tokens
                existing["last_updated"] = datetime.now()
            else:
                # Create new cumulative position
                self.active_positions[cumulative_position_id] = {
                    "position_id": cumulative_position_id,
                    "token_pair": signal.token_pair,
                    "entry_price": current_price,
                    "current_price": current_price,
                    "size": tokens_purchased,
                    "strategy": self.name,
                    "unrealized_pnl": 0,
                    "created_at": execution_result["timestamp"],
                    "total_invested": signal.suggested_amount,
                    "purchase_count": 1
                }
            
            self.trade_history.append(execution_result)
            self.performance_metrics["total_trades"] += 1
            
            self.status = StrategyStatus.MONITORING
            return execution_result
            
        except Exception as e:
            logger.error(f"Error executing DCA signal: {e}")
            self.status = StrategyStatus.ERROR
            return {"error": str(e)}


class StrategyManager:
    """Manages multiple trading strategies"""
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.global_risk_limits = {
            "max_total_exposure": 10000,  # $10k max
            "max_strategies_active": 5,
            "max_single_strategy_allocation": 0.5  # 50% of portfolio
        }
        self.portfolio_value = 0
        
    def add_strategy(self, strategy: BaseStrategy) -> bool:
        """Add a new strategy"""
        if len(self.strategies) >= self.global_risk_limits["max_strategies_active"]:
            logger.warning("Maximum number of strategies already active")
            return False
        
        self.strategies[strategy.name] = strategy
        logger.info(f"Added strategy: {strategy.name}")
        return True
    
    def remove_strategy(self, strategy_name: str) -> bool:
        """Remove a strategy"""
        if strategy_name in self.strategies:
            del self.strategies[strategy_name]
            logger.info(f"Removed strategy: {strategy_name}")
            return True
        return False
    
    async def run_all_strategies(self) -> Dict[str, List[TradeSignal]]:
        """Run all active strategies and collect signals"""
        all_signals = {}
        
        for name, strategy in self.strategies.items():
            try:
                logger.info(f"Running strategy: {name}")
                signals = await strategy.generate_signals()
                all_signals[name] = signals
                
                # Update positions for monitoring strategies
                if strategy.status == StrategyStatus.MONITORING:
                    await strategy.update_positions()
                    
            except Exception as e:
                logger.error(f"Error running strategy {name}: {e}")
                all_signals[name] = []
        
        return all_signals
    
    def get_portfolio_summary(self) -> Dict[str, Any]:
        """Get overall portfolio summary"""
        total_positions = sum(len(s.active_positions) for s in self.strategies.values())
        total_pnl = sum(s.performance_metrics["total_pnl"] for s in self.strategies.values())
        total_trades = sum(s.performance_metrics["total_trades"] for s in self.strategies.values())
        
        return {
            "total_strategies": len(self.strategies),
            "active_strategies": len([s for s in self.strategies.values() if s.status != StrategyStatus.IDLE]),
            "total_positions": total_positions,
            "total_pnl": total_pnl,
            "total_trades": total_trades,
            "portfolio_value": self.portfolio_value,
            "strategies_performance": {
                name: strategy.get_performance_summary() 
                for name, strategy in self.strategies.items()
            }
        }
    
    async def emergency_stop_all(self):
        """Emergency stop all strategies"""
        logger.critical("Emergency stop activated for all strategies")
        
        for name, strategy in self.strategies.items():
            strategy.status = StrategyStatus.STOPPED
            logger.info(f"Stopped strategy: {name}")
            
            # Close all positions (simplified - in production, execute actual close orders)
            for position_id in list(strategy.active_positions.keys()):
                del strategy.active_positions[position_id]
                logger.info(f"Closed position: {position_id}")


# Factory function for creating strategies
def create_strategy(strategy_type: str, parameters: Dict[str, Any]) -> Optional[BaseStrategy]:
    """Factory function to create strategy instances"""
    strategy_classes = {
        "arbitrage": ArbitrageStrategy,
        "yield_farming": YieldFarmingStrategy,
        "trend_following": TrendFollowingStrategy,
        "dca": DCAStrategy
    }
    
    if strategy_type not in strategy_classes:
        logger.error(f"Unknown strategy type: {strategy_type}")
        return None
    
    try:
        strategy_class = strategy_classes[strategy_type]
        strategy = strategy_class(parameters)
        logger.info(f"Created {strategy_type} strategy with parameters: {parameters}")
        return strategy
    except Exception as e:
        logger.error(f"Error creating {strategy_type} strategy: {e}")
        return None